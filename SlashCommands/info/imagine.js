/**
 * @name AzuryIndustries
 * @description This is the handler for the bot
 * @version 1.0.0
 * @license MIT
 * @invite https://discord.gg/azury
 */

const {
    Client,
    CommandInteraction,
    ApplicationCommandType,
    ApplicationCommandOptionType
} = require("discord.js");

const Discord = require("discord.js");
const stackblur = require('stackblur-canvas');

const {
    createCanvas,
    loadImage
} = require('canvas');

const aiEngines = {
    "createMidjourney": {
        name: "Use the OpenJourney AI Engine",
    },
    "createStableDiffusion": {
        name: "Use the StableDiffusion AI Engine",
    },
}

module.exports = {
    name: "imagine",
    description: "Image an image",
    options: [{
            name: "prompt",
            description: "The prompt you want to use",
            type: ApplicationCommandOptionType.String,
            required: true,
        },
        {
            name: "engine",
            description: "The AI Engine you want to use",
            type: ApplicationCommandOptionType.String,
            required: true,
            choices: Object.keys(aiEngines).map((key) => {
                return {
                    name: aiEngines[key].name,
                    value: key,
                }
            }),
        },
    ],
    /**
     *
     * @param {Client} client
     * @param {CommandInteraction} interaction
     * @param {String[]} args
     */
    run: async (client, interaction, args) => {
        const {
            createMidjourney,
            createStableDiffusion
        } = await import('replicate-fetch');
        const prompt = interaction.options.getString('prompt');
        const engine = interaction.options.getString('engine');

        await interaction.deferReply({
            ephemeral: false
        });
        await interaction.editReply({
            embeds: [
                new Discord.EmbedBuilder()
                .setTitle("Generating image...")
                .setColor("#302c34")
            ]
        })

        let x;
        if (engine === "createMidjourney") {
            x = await createMidjourney({
                prompt
            });
        } else if (engine === "createStableDiffusion") {
            x = await createStableDiffusion({
                prompt
            });
        }

        if (!x || !x[0]) return interaction.editReply({
            embeds: [
                new Discord.EmbedBuilder()
                .setTitle("AI Generation failed. Please try again.")
                .setColor("#FF5050")
            ]
        });

        const row = new Discord.ActionRowBuilder()
            .addComponents([
                new Discord.ButtonBuilder()
                .setLabel("Download")
                .setStyle(Discord.ButtonStyle.Link)
                .setURL(x[0])
                .setEmoji("📥"),
                new Discord.ButtonBuilder()
                .setLabel("Support")
                .setStyle(Discord.ButtonStyle.Link)
                .setURL("https://discord.gg/azury")
            ]);

        const canvas = createCanvas(1000, 1000);
        const ctx = canvas.getContext('2d');

        const background = await loadImage(x[0]);

        // Draw the background
        ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.beginPath();
        ctx.rect(0, canvas.height - 100, canvas.width, 100);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#666666';
        ctx.stroke();
        ctx.fill();

        // Blur the rectangle area using stackblur
        stackblur.canvasRGB(canvas, 0, canvas.height - 100, canvas.width, 100, 30);

        ctx.font = '30px sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        const lines = await wrapText(ctx, prompt, 900);
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], canvas.width / 2, canvas.height - 50 + i * 30);
        }

        const attachment = new Discord.AttachmentBuilder(canvas.toBuffer(), {
            name: 'gg-azury.png'
        });

        interaction.editReply({
            embeds: [
                new Discord.EmbedBuilder()
                .setTitle("🍥 > Image Generation Complete")
                .setImage("attachment://gg-azury.png")
                .setColor("#302c34")
                .setFooter({
                    text: `Generated by ${engine}`
                })
            ],
            components: [row],
            files: [attachment]
        });
    },
};

async function wrapText(ctx, text, maxWidth) {
    return new Promise((resolve, reject) => {
        if (ctx.measureText(text).width < maxWidth) {
            return resolve([text]);
        }
        if (ctx.measureText('W').width > maxWidth) {
            return reject('Letter width exceeds maxWidth');
        }
        const words = text.split(' ');
        const lines = [];
        let line = '';
        while (words.length > 0) {
            let split = false;
            while (ctx.measureText(words[0]).width >= maxWidth) {
                const temp = words[0];
                words[0] = temp.slice(0, -1);
                if (split) {
                    words[1] = `${temp.slice(-1)}${words[1]}`;
                } else {
                    split = true;
                    words.splice(1, 0, temp.slice(-1));
                }
            }
            if (ctx.measureText(`${line}${words[0]}`).width < maxWidth) {
                line += `${words.shift()} `;
            } else {
                lines.push(line.trim());
                line = '';
            }
            if (words.length === 0) {
                lines.push(line.trim());
            }
        }
        return resolve(lines);
    });
}